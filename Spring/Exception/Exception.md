# Exception

```table-of-contents
```

##  Exception

- 자바의 모든 객체는 Object. 예외 역시 객체.
- Throwable : 최상위 예외. 자식으로는 Exception과 Error를 가진다.
- Error : 메모리 부족이나 심각한 시스템 오류 등과 같이 애플리케이션에서는 복구가 어려운 시스템 수준의 예외. 따라서 애플리케이션 개발자는 이 예외를 잡아서는 안된다.
    - 상위 예외를 catch로 잡는 로직의 경우, 그 자식 타입까지 모두 잡게 된다. 따라서 Throwable을 catch문으로 잡으려고 하면, 애플리케이션에서 메모리 부족 에러까지 잡으려고 하는 것이기 때문에 안된다.
    - Error 역시 언체크 예외에 속한다.
- Exception : 체크 예외
    - 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외
    - Exception과 그 하위 예외는 모두 체크 예외(컴파일러가 “체크”하는 예외). 단 RuntimeException은 자식이지만 언체크 예외
- RuntimeException : 언체크 예외 혹은 런타임 예외
    - 컴파일러가 체크하지 않는 언체크 예외
    - RuntimeException의 하위는 모두 언체크 예외

## 예외 기본 규칙

- 예외의 2가지 기본 규칙
    1. 예외는 잡아서 처리하거나 (catch), 던져야한다(throw).
    2. 예외를 잡거나 던질 때, 지정한 예외뿐만 아니라 그 예외의 자식들도 함께 처리된다.
- 예외를 처리하지 못하고 계속 던지게 되면
    - 자바의 main() 쓰레드의 경우 예외로그를 출력하면서 시스템이 종료
    - 웹 어플리케이션의 경우, 한 사용자의 요청 때문에 전체 시스템이 종료되면 안되기 때문에, WAS가 해당 예외를 마지막에 받아서 처리 → 주로 개발자가 지정한 오류페이지를 보여주는 형식

## 체크 예외의 장단점
- 체크 예외의 경우, 예외를 해당 코드에서 잡아서 처리할 수 없을 때에는, 예외를 밖으로 던지는 throws문을 필수로 선언해야 컴파일 오류가 나지 않는다.
	- 장점 : 개발자가 실수로 예외를 누락하지 않도록 컴파일러가 문제를 잡아주는 안전 장치 역할
	- 단점 : 실제로는 개발자가 모든 체크 예외를 반드시 잡거나 던지도록 처리해야하므로 번거롭고, 또한 해당 계층(예를들면 service)에서는 크게 신경쓰지 않은 예외까지 모두 챙겨야 하며, 마지막으로 예외로 인해서, 불필요한 의존관계가 발생할 수 있다는 단점이 있다.

## 언체크 예외의 장단점

- 언체크 예외는 컴파일러가 체크해주지 않는 예외들이다. 언체크 예외와 체크 예외는 기본적으로 동일하지만, 언체크 예외의 경우에는 throws를 선언해주지 않아도 알아서 자동으로 예외를 던진다.(명시적으로 선언해도 되긴함)
	- 장점 : 신경쓰지 않은 언체크 예외를 무시할 수 있다. throws문을 작성하지 않아도 되기 때문에, 작성해야 하는 코드 수도 줄고, 어떤 예외들을 처리해야 하는지 신경을 쓰지 않아도 되며, 의존관계에서도 좀 더 자유롭다.
	- 단점 : 개발자가 실수로 예외를 누락했을 때, 컴파일러가 잡아주지 못한다.


## 체크 예외 vs 언체크 예외

- 기본적으로는 언체크(런타임) 예외를 사용하는 것을 권장.
- 체크 예외를 주로 사용하는 경우에는 크게 두가지 문제점이 발생할 수 있다.
	- 복구 불가능한 예외 
		- 상당수의 예외들이 각 컴포넌트에서 복구해주지 못하는 경우가 많음에도, 무의미하게 처리를 강요받아야 한다. 이 경우에 해당 컴포넌트에서 할 수 있는 것은 오류 로그를 남기고 상위로 에러를 던지는 것 밖에 불가능한데, 이를 위해 매번 코드에 throws문을 선언해 주어야 한다.
	- 의존 관계에 대한 문제 
		- [OCP](../../JAVA/SOLID.md), [DI](../../CS/디자인%20패턴/의존관계%20주입.md)를 통해 클라이언트의 코드 변경 없이 대상 구현체를 변경할 수 있다는 것이 스프링의 최대 장점이지만, 만약 기술의 변경 등으로 인해 다른 구현체를 주입하려고 할 때, 던지는 예외가 달라지는 경우 문제가 생긴다.
		- 예를들어 [Repository](../../미완성%20문서/@Repository.md)의 구현체를 기존 [JDBC](../../JAVA/JDBC.md) 기술을 활용 하던 것에서, [JPA](../../미완성%20문서/JPA.md) 기술을 활용하는 구현체로 변경하려고 할 때, 던지는 체크 예외의 유형에 맞춰 호출 하고 있는 곳에서 모두 바꿔줘야 하는 문제점이 있다.
		- 다시 말하면 의존성 주입을 했다 해도, 체크 예외 때문에 아직 예외의 의존성이 남아 있게 되는 것이다.
- 이런 경우 언체크 예외를 활용하면 [Service](../../미완성%20문서/Service.md)나 [Controller](../Spring%20MVC/Controller.md)단에서는 신경쓰지 않고, 예외 공통 처리 부분에서 한꺼번에 잡아서 처리하도록 구성할 수 있으며, 기술변경에 따른 변화도, 공통 처리 부분으로만 최소화 시킬 수 있다. 자세한 내용은 [데이터 접근 예외](데이터%20접근%20예외.md) 참조
- 참고로 모든 곳에 throws Exception을 붙여서 최상위 예외로 만들어두면 의존성 문제나 변경 문제가 해결 되기는 하지만, 의도한 예외 이외에도 다른 모든 체크 예외도 던져지기 때문에, 컴파일러가 원래 잘 처리하던 체크 예외를 잡아내는 기능이 무효화 되므로, 바람직한 방법이 아니다.


## 언체크 예외를 활용해야 하는 이유

- 기본적으로는 언체크 예외를 사용할 것을 권장
	- 체크 예외의 경우 비지니스 로직상 의도적으로 던지는 예외에만 사용할 것
	    - 예)
	        - 계좌이체 실패 예외
	        - 결제시 포인트 부족 예외
	        - 로그인 ID, PW 불일치 예외
	    - 이처럼 해당 예외를 반드시 처리해야 하는 문제라고 판단될 경우에만 체크 예외를 사용

> [!Important] 트랜잭션 그리고 Commit과 Rollback
> - 스프링은 기본적으로 체크 예외는 비지니스 의미가 있을 때 사용, 언체크 예외는 복구 불가능한 예외로 가정하고 사용
> - 따라서 스프링 [트랜잭션](../../CS/트랜잭션.md)은 체크 예외 발생 시에는 커밋, 언체크 예외 발생시에는 롤백 수행이 기본 설정
> - 예 ) 주문 상황
> 	- 정상 : 주문시 결제를 성공하면 주문 데이터를 저장하고 결제상태를 완료로 처리 → 커밋
> 	- 시스템 예외 : 주문시 내부에 복구 불가능한 예외 발생 → 롤백
> 	- 비지니스 예외 : 주문시 고객의 잔고 부족 → 주문데이터를 저장하되, **결제 상태를 대기로 처리(커밋)**, 고객에게 잔고 부족안내, 입금 후에 저장해둔 **정상 주문 재개**
> - 이러한 비지니스 예외의 경우, 시스템의 오류가 아닌 비지니스 상황이 오류이며, 반드시 조치를 취해야 하기 때문에 체크 예외를 고려하는 경우가 많음


## 스택 트레이스

- 런타임 예외를 직접 만들어서 사용하는 경우, **꼭 기존 예외를 포함해서 만들어야 스택 트레이스가 남는다**
- 항상 원래 오류를 생성자에 포함시켜주는 것으로 하여, 스텍트레이스로 에러를 추적할 수 있도록 하기