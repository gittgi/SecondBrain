---
tags:
  - MVC
---

# MVC

```table-of-contents
```

##  MVC란?


### 기존의 문제점

- [JSP](../../CS/Web/JSP.md)나 [서블릿](../../CS/Web/서블릿.md)의 예를 들어, 하나의 객체가 비지니스 로직 수행과 뷰 렌더링을 모두 처리하게 되면, 너무 많은 역할로 인해 유지보수가 어려워 질 수 있다
	- 비지니스 로직을 호출하는 부분에서 변경이 발생해도 해당 파일을 수정해야 하고, UI를 변경 해야 할 때에도 해당 파일을 수정해야 한다.
	- HTML 코드를 수정하려 할 때, 같이 섞여있는 자바 코드들 역시 고려해야 하는 상황이 발생할 수도 있기 때문에, 유지보수 측면에서 비효율적이다.
- 뿐만 아니라 비지니스 로직과 UI (View)의 경우에는 변경 라이프 사이클이 다르다.
	- 비지니스 요구 사항에 맞춰 로직을 변경하고자 할 때, UI의 경우에는 변화 소요가 없을 가능성이 높다.
	- 반대로 UI를 개선하려고 할 때, 비지니스 로직 및 필요한 데이터의 경우에는 그대로 유지해도 되는 상황이 많다.
	- 이처럼 수정의 라이프 사이클이 서로 독립적인 두 영역을 한 코드에서 같이 관리하는 것은 유지 보수 측면에서 


### Model View Controller

- 위와 같은 문제점들에 대해, 하나의 [서블릿](../../CS/Web/서블릿.md) 혹은 [JSP](../../CS/Web/JSP.md)으로 처리하던 방식에서 벗어나, 컨트롤러와 뷰(View)의 영역으로 역할을 나누게 됨
	- [컨트롤러](Controller.md) : 요청을 받아서 파라미터를 검증하고 비지니스 로직을 실행하는 역할, 실행 결과 데이터를 조회해서 모델에 담아 뷰에 전달하는 역할을 담당
		- 최근에는 순수하게 비지니스 역할만을 담당하는 [서비스](../../미완성%20문서/Service.md) 계층을 따로 두어, 서비스 계층에서 비지니스 로직을 실행하고, 컨트롤러는 적절한 서비스를 호출하는 역할을 나누는 것이 일반적
	- [모델](../../미완성%20문서/Model.md) : 뷰에 출력할 데이터를 담는 곳, 컨트롤러에서 뷰로 데이터를 옮기는 역할 -> 뷰는 모델의 데이터를 가져다 쓰면 되기 때문에, 비지니스 로직이나 데이터 접근 등을 몰라도 된다.
	- 뷰 : 모델에 담겨있는 데이터를 바탕으로 화면을 그리는 역할


### 서블릿에서의 MVC

- [서블릿](../../CS/Web/서블릿.md)을 [컨트롤러](Controller.md)로 사용할 때, [모델](../../미완성%20문서/Model.md)은 [HttpServletRequest](HttpServletRequest.md) 객체를 사용할 수 있다.
	- HttpServletRequest 객체 내부에 있는 데이터 저장소를 사용해서 컨트롤러와 뷰 사이에 데이터를 전달 할 수 있다.
	- 컨트롤러에서는 `request.setAttribute("키", 밸류)`를 이용해서 모델에 데이터를 저장 가능
	- 뷰( 가령 [JSP](../../CS/Web/JSP.md) )에서는 `request.getAttriute("키")` 를 통해 모델에서 데이터를 꺼내 쓸 수 있다.
		- JSP의 경우 `${}` 의 문법을 통해 데이터를 쉽게 꺼낼 수 있고, 다른 템플릿 엔진의 경우에도 편리하게 데이터를 꺼낼 수 있는 문법을 제공


## MVC 컨트롤러의 단점과 프론트 컨트롤러

- 뷰와 컨트롤러의 역할을 나누는 것으로 코드가 직관적으로 변하고, 유지보수 측면에서도 효율 강화
- 그러나 서블릿을 컨트롤러로 바로 사용하는 방식에는 중복 코드가 많다(포워드 코드나 View Path 중복 등)
- 또한 컨트롤러에서 공통으로 처리해야 하는 부분들이 증가함에 따라, 매번 컨트롤러에서 누락 없이 호출 해줘야 하는 메서드들이 증가하는 것이 부담(호출 자체도 중복됨)
- 
> [!Note] 결론은 공통 처리 문제
> 따라서  컨트롤러 호출 전에 먼저 공통 기능을 처리하는 [프론트 컨트롤러](프론트%20컨트롤러.md) 패턴을 도입하는 것으로 해결 
> -> [Spring MVC](스프링%20MVC.md)
