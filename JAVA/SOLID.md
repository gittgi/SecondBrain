# SOLID

- **Single Responsibility Principle (SRP, 단일 책임 원칙)**
	- 한 클래스는 **하나의 책임**만 가질 것
		- 책임의 정의는 맥락과 상황에 따라 다를 수 있기에, 딱 정의하기 어렵다.
		- 따라서 변경 사항이 있을 때, 이 변경으로 인한 파급효과를 최소화 되도록 책임을 한정시키는 것이 핵심
	- 예시로는 UI 변경으로 인해 기능적인 수정이 생기지 않도록 렌더링 관련 클래스의 책임을 한정하거나, 별도의 객체를 생성하는 객체와 사용하는 객체를 분리해서 생성 객체는 생성하는 책임만, 사용 객체는 사용하는 책임만 지게하는 것([스프링 컨테이너](../Spring/스프링%20컨테이너.md))

- **Open/Closed principle (OCP, 개방-폐쇄 원칙)**
	- 소프트웨어 요소는 **확장에는 열려있되, 변경에는 닫혀 있을 것**
		- 다형성을 활용하는 것으로 가능
			- 같은 인터페이스를 구현한 클래스들을 서로 바꿔끼는 것으로 기능을 **확장**
			- 동시에 해당 구현체 클래스들을 호출하는 부분에는 구현체가 아닌 인터페이스를 기준으로 코드를 작성하여, 구현체가 변경되더라도 코드 자체를 수정 혹은 **변경**하지 않아도 되도록 설계하라는 것
			```JAVA
			public class MemberService { 
				// private MemberRepository memberRepository = new MemoryMemberRepository(); // 기존 레포지토리
				private MemberRepository memberRepository = new JdbcMemberRepository(); // 새 레포지토리로 변경 }
```
			- 다만 이 경우에도 불가피한 코드 변경(주석 처리 및 새 코드 작성)이 요구됨 -> 따라서 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요 ([의존관계 주입](../Spring/의존관계%20주입.md))

- **Liskov Substitution Principle (LSP, 리스코프 치환 원칙)**
	- 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
	- 하위 클래스는 상위 클래스 혹은 인터페이스의 규약을 다 지켜야 한다는 뜻
	- 이는 단순히 컴파일 오류가 안나는 수준을 뜻 하는것이 아니라 기능적으로도 상위 타입의 규약을 지키라는 뜻(자동차 인터페이스의 액셀을 구현한다면, 느리더라도 앞으로 구현해야 함. 뒤로 구현한다면 그것은 LSP 위반)
	- 이 원칙이 지켜져야 인터페이스를 기반으로한 구현체를 이용한 다형성이 성립할 것

- **Interface Segregation Principle (ISP, 인터페이스 분리 원칙)**
	- 특정 클라이언트를 위한 인터페이스를 세분화하여 여러개 두는 것이 범용 인터페이스 하나를 두는 것보다 좋다
	- 자동차와 관련된 인터페이스를 하나 두는 것보다, 운전 인터페이스와 정비 인터페이스로 나눠 두는 것
		- 각각의 인터페이스를 구현한 운전자 구현체와 정비사 구현체가 있다고 했을 때, 자동차의 기관이 내연기관에서 전기기관으로 바뀌는 경우에 정비 인터페이스에는 많은 변경 사항이 생겨도 운전자 구현체는 그대로 핸들과 액셀등을 동일하게 사용가능
	- 즉, 인터페이스를 분리하는 것으로 각각의 인터페이스가 명확해지고, 변경시에 대체하는 것도 더 용이해진다.

- **Dependency Inversion Principle (DIP, 의존관계 역전 원칙)**
	- "구체화에 의존하지 말고 **추상화에 의존할 것**"
	- 다시 말해 구체 클래스 대신 인터페이스에 의존해야 함을 제시
	- 다른 객체를 호출하는 것에 있어서 직접적으로 해당 구체 클래스를 코드에 작성하게 되면, 해당 구체 클래스에 의존하게 됨
		- 이는 곧 해당 구체 클래스의 변경에 직접적인 영향을 받게되는 것이고, 해당 구체클래스에 변경에 따라 수정사항이 발생하게 되는 것을 의미함
		- 따라서 구체클래스에 의존하는 대신 인터페이스에 의존하는 것으로 문제를 해결할 수 있음
		- 인터페이스를 충실히 구현한 구현체이기만 하다면, 구현체의 내부 로직 변경을 신경 쓸 필요가 없어지고, 심지어는 다른 구현체로 변경하는 것 역시 신경 쓰지 않아도 됨
	- 다만 인터페이스에 의존하고자 해도 결국 해당 인터페이스를 구현한 구체클래스를 한번은 호출해야 하기 때문에, 여전히 의존하게 되는 문제가 있음 -> 이는 [의존관계 주입(DI)](DI)))).md)을 통해 해결 가능

---
연관 링크 : [ ]
