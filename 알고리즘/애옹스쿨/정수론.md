# 정수론

```table-of-contents
```

## 1.  소수 판정 `O(sqrt(n))`

- **약수는 쌍으로 존재**
	- 1 12
	- 2 6
	- 3 4
- 즉, **이 쌍이 하나 (1, 12)인 애가 소수**

- 같은 원리로 36의 경우에는 
	- 1 36
	- 2 18
	- 3 12
	- 4 9
	- 6 6
- 이때 **6을 기준으로 작은 수와 큰 수의 쌍**으로 존재 => 즉 **루트 n까지 약수가 없으면 약수가 없는 것**

```python
n = int(input())

if n == 1:
	print("소수가 아니다")
	exit()

cnt = 0 
for i in range(2, n+1):
	if i * i > n: # 루트 n까지만 찾아보면 됨
		break
	if n % i == 0:
		cnt += 1

if cnt == 0:
	print("소수다")
else:
	print("소수가 아니다")
```


## 2. 약수 구하기 `O(sqrt(n))`

- 소수 판정에서 본 것처럼, **약수는 쌍**으로 존재
- 따라서 **루트 n까지만 구하면서, i와 n // i를 같이 구하면** 작은 수와 큰 수의 쌍을 모두 구할 수 있음
	- 그러나 **제곱수의 경우에는 마지막 쌍이 i * i**가 문제가 될 수 있기 때문에, 따로 처리를 해주어야 함

- 약수는 기본적으로 약수의 개수가 짝수
	- 약수의 개수가 홀수다? == 제곱수

## 3. 소인수 분해 `O(sqrt(n))`

1. n의 소인수를 다 곱하면 n
2. 루트 n 보다 큰 값 * 루트 n 보다 큰 값 == n보다 큼
- **따라서 루트 n 보다 큰 소인수는 2개 이상 존재 할 수 없다**
- == 루트 n 보다 큰 소인수가 없거나 하나

- 따라서 소인수의 경우의 수는 다음 둘 중 하나
	1. 루트 n 보다 큰 소인수가 없는 경우
	2. 루트 n 보다 큰 소인수가 정확히 하나 있는 경우
- **루트 n보다 작은 애들까지만 다 찾고, 만약 남은 애가 있다면 딱 하나 있는 큰 소인수**

```python
# 초기값 n
x = n
for i in range(2, n+1):
	if i * i > n:
		break
	while x % i == 0:
		print(i)
		x //= i
# 이 방식으로 루트 n 보다 작은 소인수를 모두 거르고
# 만약 남은 n이 있다면 걔가 딱 하나 남은 루트 n보다 큰 소인수!
if x != 1:
	print(x)
```

## 4. 유클리드 호제법 `O(log(n))`

- 8 은 2씩 건너뛰어서 도달할 수 있으므로 2는 8의 약수
- 8은 4씩 건너뛰어서 도달할 수 있고, 12 역시 도달할 수 있다 => 공약수
	- 8을 찍고 12에도 도달할 수 있다는 것은, 8을 원점으로 해서 12까지 도달할 수 있다는 뜻
		- 즉 4 는 (12 - 8) 의 약수 역시 증명됨
	- 결론적으로, **a와 b의 공약수는 a-b (a > b)의 약수이기도 함!**

- +) **a, b, a-b 는 공약수를 공유** => 최대공약수 구하기
	- gcd(a, b) == gcd(a, a-b) == gcd(b, a-b)
	- 계속해서 빼나가다보면, 작은 수 두개의 최대공약수를 구하는 문제로 단순화됨
		- gcd(436, 124) == gcd(312, 124) == gcd(188, 124) == gcd(124, 64) == gcd(64, 60) == gcd(60, 4)
		- (a>b) 일 때 gcd(a, b) => gcd(b, a % b)로 바로 구하기 가능

```python
def get_gcd(a, b):
	while a % b != 0: # 한 쪽이 다른 한쪽의 배수가 되면 공약수 찾기 끝!
		a, b = b, a % b 
	return b 
```

**최소공배수 공식 : LCM(A, B) == A * B // GCD(A, B)** 

## 5. 에라토스테네스의 체 `O(nlog(log(n)))`

- 1부터 n까지의 소수를 모두 구하는 방법
	- 1 외에는 **모두 소수라고 가정**
	- 2부터 반복
		- 만약 i가 소수라면 얘의 **배수는 모두 지우기**
		- 만약 i가 **소수가 아니라면 스킵**(이미 i의 배수는 이전에 다 지워짐)
```python
isPrime = [True for i in range(n+1)]
isPrime[1] = False
for i in range(2, n+1):
	if not isPrime[i]:
		continue
	# 이미 i보다 작은 수를 곱한 배수들은 이전 순회때 처리되었기 때문에 i*i부터 보면 됨
	for j in range(i * i, n+1, i): 
		isPrime[j] = False
		
```



## 6. 1~N 까지 k의 배수의 개수

- **n // k 개** 


## 7.  n!에 곱해져 있는 소수 k의 개수 `(O(log(n))`

```python
# O(nlog(n))
for i in range(1, n+1):
	while i % 2 == 0:
		cnt += 1
		i //= k
```
는 시간이 너무 오래걸림

- 2의 개수를 쌓아보면
```python
1 2 3 4 5 6 7 8 9 10
  o   o   o   o   o  2의 배수는 n // 2개
      o       o      4의 배수는 n // 4개
              o      8의 배수는 n // 8개
```
- 세로로 하나하나 세면 위의 코드처럼 타임아웃
	- 관점을 바꿔서 가로를 세보자
- 따라서 k의 거듭제곱의 배수의 개수의 합으로 구할 수 있다.
- 이런 식으로 관점을 바꿔서 생각해야 할 경우가 많이 있을것... 


## + 모듈러의 성질

- (a + b) % 3 을 구하고 싶은데 a + b의 크기가 커서 오버플로우가 날거 같을 때
	- a % 3을 구하고 b % 3을 구한 다음에 더하고 그 뒤에 % 3을 해줘도 됨
	- (10 + 20) % 3 => (1 + 2) % 3
- 마찬가지로 (a * b) % 3 에도 적용가능
	- (a % 3 * b % 3) % 3
- 원래는 수학적으로 사칙연산에 다 가능하지만, 정수 나누셈은 컴퓨터 이슈로 안됨... 페르마소 정리로 할 수는 있다고함 
- **결론은 모듈러 적용 전에 수가 너무 커질거 같으면, 각각 모듈러 적용하고 계산하는게 낫다**

- 모듈러를 사용하면 순환형이 되는 효과가 있음
- 0 1 2 3 4   5 6 7 8 9  10 11 12 13 14
- 0 1 2 3 4   0 1 2 3 4  0 1 2 3 4

## + 거듭제곱 빠르게 구하기


## 문제풀이
### 2로 몇번 나누어질까?
- 일단 홀수는 f(x)값이 1이겠구나
- f(x) 가 1이 나오는게 몇개인지, 2가 나오는게 몇개인지, 4가 나오는게 몇개인지...
	- 1 인건 홀수 만큼 (n // 1 - n // 2)
	- f(x)가 2가 나온다는 건, 2의 배수이지만 4의 배수는 아니어야 함 -> **2의 배수에서 4의 배수를 빼주면 됨** -> (n // 2 - n // 4) * 2
	- 4가 나온다는건 4의 배수지만 8의 배수는 아니어야함 -> **4의 배수에서 8의 배수를 빼주면 됨** -> (n // 4 - n // 8) * 4

### 최대공약수 하나 빼기
- 하나를 뺄 때 GCD -> n개 중 하나가 정답
	- 1번째를 뺀다, 2번째를 뺸다...
	- 1 번째를 뺀다 / 다른걸 뺸다(2, 3, 4, 5)
		- 둘중 하나가 답
		- 1번쨰를 뺸다는 바로 구할 수 있음 (첫번쨰 뺴고 나머지의 gcd)
	- 다른걸 뺸다 -> 첫번째걸 남긴다 -> 첫번째 거의 약수가 남는다.
		- 첫번째거의 배수가 아닌 걸 나머지에서 찾는다
		- 그 다음 약수를 찾아내면서 결정
- 근데 완전탐색도 시간이 된다고함..
