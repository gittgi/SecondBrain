# B형 특강

```table-of-contents
```

##  B형 특강

- 온라인 쿼리를 어떻게 처리할 것인가

- 온라인 쿼리란?
	- 3 7    1
	- 2 10  2
	- 3 9  3
	- ? 2번 update까지 처리했을 때에 3번 자리에는 뭐가?   !7
	- ? 3번 시점에 3번 자리에는 뭐가? !9
	- pst 문제...

- 오프라인 쿼리 : 쿼리 전체가 미리 주어지고, 순서를 바꿔서 처리해도 된다.
- 온라인 쿼리 : 다음에 어떤 쿼리가 주어질지 모른다. 그때 그때 처리 해줘야 한다.

- 온라인 쿼리를 처리할 떄 많이 나오는 테크닉
1. lazy 처리
2. small to large
3. sparse table(LCA)
4. 해싱, 압축 기술 (라빈카프)
5. 유니온 파인드 롤백
6. 세그먼트 트리(의 편한 구현)

extra. 트라이, 펜윅, sqrt decomposition, mo's
lazy 세그 -> propagation 알아야 함..

## Lazy 처리
- **update가 너무 무거운 경우, get 할 때 한번에 처리하자는 게 핵심**
	- IMOS도 LAZY 처리의 예시
- pop(8) -> 지금 빼려면 다 빼고 다시 넣고 너무 헤비함
	- 8을 하나 뻈다고 치고 기록만 해두고
	- 나중에 get할 때마다 체크해서 만약에 8이 나오면 아까 뺐어야 한다고 기록해 둔걸 보고 8을 get하지 않고 그때 없애줌
- 세그먼트 트리의 Lay Propagation
- Union-find의 union by rank
	- 두 그룹을 하나로 합칠 수 있다
	- 특정 그룹에 점수를 일괄로 더해줄 수 있다
	- 각 개인의 점수를 계산해야 한다면?
		- 리프 노드 기준으로, find를 통해 루트노드로 올라가면서, 그 과정에서 만나는 모든 노드 들의 합을 기억하면 어떨까?
		- 루트가 10이고 내가 5면 5 - 10인 -5를 내 값으로 기억해두기
		- 만약에 루트(10)이 다른 루트(8) 밑으로 연결된다면 루트를 10 - 8 = 2로 저장
		- 이제 루트까지 find하면서 계산하면 각 리프 노드가 자신의 값을 기억할 수 있다

## Small to Large
- 사실상 union by rank와 같은 원리
- Union - find 로 모든 요소를 하나의 집합으로 묶을 때 그냥 하면 최악의 경우 N^2
- 작은 집합을 큰 집합으로 합치기
	- 이렇게 하면 NlogN이 보장됨
		- 어떤 노드를 기준으로, 만약 해당 노드가 속한 집합으로 이동했다는 뜻은, 다른 집합이 자신이 속한 집합보다 같거나 크다는 뜻 -> 이동 후의 내가 속한 집합의 크기가 이전 집합의 2배 이상이 됨 -> 아무리 못해도 NlogN에 최대 크기(모두 통일)가 가능
	- 이때 각 집합에 몇개 들어있는지 기억해 둘 필요가 있음


## sparse table(LCA)

- update가 없고 get 만 있는 온라인 쿼리 가능
- 그래프 형태에서, 모든 노드가 단방향으로 나가는 간선이 딱 하나씩 있을 때
- 1 => 2
- 2 => 5
- 3 => 6
- 4 => 6
- 5 => 7
- 6 => 3
- 7 => 2
- 1에서 출발해서 100만번 이동하면 어디에 있을 것인가? 10억번 이후에는?
- 각 칸에서 1칸 뒤, 2칸 뒤, 4칸 뒤, 8칸 뒤, 16칸 뒤....를 저장할 수 있다
- 1에서 1칸 뒤는 2
- 1에서 2칸 뒤는 2에서 한칸 뒤인 5
- 1에서 4칸 뒤는 4에서 2칸 뒤인 2
- 1에서 8칸 뒤는 2에서 4칸 뒤인 5....
- 즉 각 노드에서 1칸 뒤를 다 채운 뒤에, 2칸 뒤는 방금 채운 1칸 뒤 정보로 다 채울 수 있고, 그 후에  4칸 뒤 정보는 2칸 뒤 정보로 다 채울 수 있음
	- 30번 반복하면 10억번 (2^30)이후도 채울 수 있음
- 이제 그 테이블을 기준으로 13번째 뒤를 찾고자 한다면 8 + 4 + 1번째로 구할 수 있음
- 13 -> 1101로 표현 한 뒤에
```java
int nxt[0][i] = arr[i]
for (int i = 1; i < 30; i++) {
	for(int j = 1; j <= n; j++) {
		nxt[i][j] = nxt[i - 1][nxt[i - 1][j]]
	}
}


for(int i = 0; i < 30; i++) {
	// 비트가 켜져 있으면 해당 번호 만큼 이동 하라
	if((y & (1 << i)) != 0) {
		x = nxt[i][x]
	}
}
```

- 내 5칸 위의 조상이 누구냐? 같은 걸 쓸때 좋다 (LCA)



## 해싱 / 압축

- 라빈카프
- 금메달 > 은메달 > 동메달 순으로 랭킹 매기기 (금메달이 같으면 은메달 세기)
	- 각 메달이 1000개 미만이면(이정도로 작으면)
		- stable sort로 동메달 은메달 금메달 순으로 3번 정렬하거나
		- 금메달 x 1000^2 + 은메달 x 1000 + 동메달로 정렬 해버리면 됨
			- 이 경우에는 시간 복잡도에서 상수부분을 크게 줄이는 효과가 있다 (O(16N)일떄 8분의 1로 O(2N)으로 줄여주는 느낌)


## Union find rollback

- union by rank 기준
- 합치는 과정에서 스택에 어떤 루트노드가 자기 부모와 연결되었는지 저장
- 만약 롤백이 필요하다면, 스택에서 꺼내서 해당 루트노드가 다시 자기자신을 가리키게 하면 롤백 가능
	- 스택에 담을 때, 노드 뿐만 아니라 랭크 변화가 있었는지 까지 T/F를 같이 넣어주고, 랭크 변화가 있었다면 붙어 있던 루트 노드의 랭크를 하나 줄여줘야함
	- 마찬가지로 뭔가 노드에 값이 담긴다면, 그 값도 스택에 저장해서 롤백할 수 있게 구현할 것
- 이 방식은 마치 ctrl-z 하듯이 바로 직전 상황으로 하나씩 돌리는게 가능 (아무거나 되돌리는건 아니고 뒤에서부터 차례대로)
- 벽 부수고 이동하기 4 -> 상하좌우 다 union하고, 사이즈 체크한 뒤에 원상태로 롤백해주기


## 세그먼트 쉽게 구현

- 무조건 포화이진트리로 만들기
	- 사이즈가 2의 거듭제곱 (시작노드는 무조건 1부터)
	- len는 그 절반 -> **리프노드의 맨 왼쪽 노드가 len** <= 이 점을 활용하면 리프노드에서 쉽게 update 등을 하고, 이후 위로 올라가면서 update 하기 쉬워짐
- 자식 노드 왼쪽은 2x, 오른쪽은 2x+1

```cpp
const int SIZE = 1 << 20;
const int len = 1 << 19;
int tree[] = new int[SIZE];


void make_tree(){
	for(int i = len - 1; i >= 1; i--){
		tree[i] = tree[2 * i] + tree[2 * i + 1]
	}
}

void update(int idx, int v){
	idx += len;
	while(idx >= 1){
		tree[idx] += v;
		idx /= 2;
	}
}

void update2(int idx, int v) {
	idx += len;
	tree[idx] = v;
	idx /= 2;
	while (idx >= 1){
		tree[idx] = tree[2 * idx] + tree[2 * idx + 1];
	}

}

int get(int idx, int s, int e, int ts, int te){
	int mid = (s + e) / 2;
	if(s > te || e < ts) return 0;
	else if(ts <= s && e <= te) return tree[idx];
	return get(2 * idx, s, mid, ts, te) + get(2 * idx + 1, mid + 1, e, ts, te);
}

(main)
for(int i = 0; i < n; i++){
	tree[i + len] = arr[i]
}
```