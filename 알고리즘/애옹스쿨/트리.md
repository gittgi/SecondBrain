# 트리

```table-of-contents
```

##  트리의 정의

### 트리의 특징
1. 모든 노드가 하나의 연결요소
2. 사이클이 없어야 함
3. 노드의 개수가 간선의 개수보다 하나 많음 (위 두개가 만족되면 이 조건은 자동)
- 이 중에 두개를 만족하면 트리라고 보면 됨
- 2번만 주어지는 경우에는 -> 각각의 연결 요소는 트리 -> 포레스트 -> 각각 트리처럼 해결하면 됨 


### 실제 정의
- 임의로 두 노드를 연결하는 단순 경로가 정확히 하나 존재하는 그래프


## rooted tree
-  상하관계나 계급도 같은걸 사용할 때 용이
- 트리를 탐색하는 좋은 테크닉
- 일반 트리는 사실상 위 조건을 만족하는 그냥 그래프
- 따라서 문제에 따라 rooted tree처럼 바꾸는 작업을 거치는게 좋음
- 같은 트리에 대해서, 어떤 노드를 루트로 삼느냐에 따라서 달라짐

### 용어
- 루트
	- 루티드 트리에서 맨 위에 있는 애가 루트
- 리프
	- 자기 아래의 다른 노드(자식)가 없는 노드
- 부모 / 자식
	- 자신의 바로 위 / 자신의 바로 아래
	- 부모는 단 하나 존재하고, 자식은 하나 이상 존재 가능
	- 리프 노드만 자식이 없고, 나머지는 하나 이상의 자식이 있다
- 조상
	- 루트부터 자기까지 내려오는 노드들이 조상
- 깊이 / 높이
	- 노드의 깊이 : 해당 노드의 루트 까지의 거리
	- 트리의 높이 : 트리 전체의 높이
- 서브트리
	- 트리 내 특정 노드를 루트로 하는 트리
	- 서브트리의 크기는 해당 서브트리에 속하는 노드의 개수


### 각 노드의 부모노드 구하기
```python
def dfs(cur, prv):
	for nxt in v[cur]:
		if nxt == prv: # 이전 노드는 부모이니 건너뛰어라
			continue
			
		par[nxt] = cur # 내 자식 노드의 부모는 나다
		dfs(nxt, cur)

```

### 각 노드의 깊이 구하기
```python
depth = [0 for i in range(n+1)]
def dfs(cur, prv):
	for nxt in v[cur]:
		if nxt == prv: # 이전 노드는 부모이니 건너뛰어라
			continue
			
		depth[nxt] = depth[cur] + 1 # 다음 dfs에서 +1 된 값을 쓸 수 있기 때문에 dfs 이전에 depth 계산
		par[nxt] = cur # 내 자식 노드의 부모는 나다
		dfs(nxt, cur)
```

### 각 노드가 루트인 서브트리의 크기 구하기
```python
depth = [0 for i in range(n+1)]
size = [0 for i in range(n+1)]
def dfs(cur, prv):
	size[cur] = 1 # 나 자신
	for nxt in v[cur]:
		if nxt == prv: # 이전 노드는 부모이니 건너뛰어라
			continue

		par[nxt] = cur # 내 자식 노드의 부모는 나다
		dfs(nxt, cur)
		size[cur] += size[nxt] # 내 아래에 대한 사이즈 결정이 끝난 뒤에 내 사이즈 계산
```


### 서브트리의 높이 구하기
```python
height = [0 for i in range(n+1)]
def dfs(cur, prv):

	for nxt in v[cur]:
		if nxt == prv: # 이전 노드는 부모이니 건너뛰어라
			continue

		par[nxt] = cur # 내 자식 노드의 부모는 나다
		dfs(nxt, cur)
		height[cur] = max(height[cur], height[nxt] + 1) # 내 아래 서브트리들 중 최고 + 1
```

### 자식 구하기
```python
def dfs(cur, prv):

	for nxt in v[cur]:
		if nxt == prv: # 이전 노드는 부모이니 건너뛰어라
			continue

		par[nxt] = cur # 내 자식 노드의 부모는 나다
		child[cur].append(nxt) # 부모 빼고는 다 내 자식
		dfs(nxt, cur)
		
```

- 위의 식을 다 합쳐서 한번의 dfs로 구현하면 모든 노드에 대해 한번에 모든 정보를 구할 수 있음


### 트리의 수열
- 각 간선이 몇번 사용되는지 체크
	- 해당 간선을 자르고
	- 왼쪽과 오른쪽의 경우의 수룰 곱해주는 것이 간선이 횔용되는 횟수
- 가장 적게 사용되는 순으로 가장 큰 값들을 매칭 시키면 최소값 가능
- 따라서 노드하나를 잡고 루티드 트리로 만들고, 루트 노드를 제외한 나머지 노드가 루트가 되는 서브트리 사이즈
- 각 서브트리 사이즈 n * 전체 트리 사이즈 - 서브트리 사이즈 -> 각 간선이 사용되는 횟수


- 아래에서 위로 올라가는 경우에는 서브트리, 위에서 아래로 내려가는 경우에는 dfs로 접근하면 좋다
- "hld" 알고리즘 추가학습 

## 트리의 지름

- 가장 먼 두 노드 간의 거리
- 가중치가 있다면 가중치를 기준으로 계산

### 트리의 지름을 구하는 방법
- 아무 노드나 잡고 dfs를 통해 가장 먼 노드를 찾는다
- 찾은 노드를 기준으로 다시 dfs를 돌려서 가장 먼 노드를 찾으면 그것이 지름

```python

def dfs(cur, prv, d):
	global mx, idx
	if mx < d:
		mx = d
		idx = cur

	for nxt in v[cur]:
		if nxt == prv:
			continue

		dfs(nxt, cur, d+1)

mx = -1
idx = 0
dfs(1, 0, 0)
mx = -1
dfs(idx, 0, 0)

```

- 아무 노드에서나 제일 먼걸 찾아주면, 그 노드가 지름에 속해있다
- 따라서 아무 노드에서 dfs 한번 돌려서 가장 먼 점을 찾고, 거기서 다시 dfs로 제일 먼 노드를 찾으면 그것이 지름


## LCA (최소 공통 조상)

- 공통 조상 중 가장 낮은 노드를 찾는 문제
- 하나의 노드의 조상을 순서대로 순회하면서, 다른 노드의 조상인지 확인
	- 두 노드의 주소를 일렬로 나열하고, 역순으로 보면 맨 뒤의 루트노드를 시작으로 같아 오다가 달라지는 점이 있음 -> 그 직전이 최소 공통 조상을 확인하는 것이 가능
	- 또는 한쪽의 노드를 카운팅배열에 표시하고 체크하는 방법도 있음
	- (또는 한쪽의 조상 노드를 정렬해서 이진탐색도 가능)






## 이진트리

- 모든 노드가 2개 이하의 자식 노드를 가진다면 이진트리
- 이진트리는 왼쪽 자식, 오른쪽 자식 이라는 개념이 생김

### 키워드
- 완전이진르리를 배열을 이용해 구현하는 방법
- 전위순회 + 중위순회 or 후위순회 + 중위순회로 트리 복구하기
- 중위순회의 의미 (binary search tree : 정렬된 배열 출력), (트리의 높이와 너비 문제 : x축 좌표 구하기)
- 위 키워드를 바탕으로 추가학습





