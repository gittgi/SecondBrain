# 이진 탐색

```table-of-contents
```

## 1.  이진탐색 아이디어
- 후보 범위 `[s,e]`
- mid 값을 볼 때, 후보 절반을 날려버릴 수 있다면 이진 탐색 가능
- 정답의 후보가 되는 구간을 줄여나가는 것이 핵심 (투포인터)

>[!Important] 이진 탐색이란?!
>- 정답 범위 ([s, e])를 관리하면서, 한번에 후보를 절반씩 날리는 행위를 반복하는 것



## 2. 이진탐색 응용

### 응용 예시 1
- 문자열 s => 계속 x 가 나오다가 그후에 계속 o 가 나온다 (xxxxxxxxoooo)
- o 중에서 가장 왼쪽에 있는 o의 인덱스 찾기
- 먼저 가운데를 확인 -> x기 때문에 왼쪽은 답이 될 수 없다
- 오른쪽 범위의 가운데 확인 -> o 이기 때문에 오른쪽은 답이 될 수 없고, 본인은 답일 수 있다
- 다시 왼쪽 범위를 보기 -> o, 다시 왼쪽만 범위로 남고, 방금 저장했던 o는 답이 될 수 없는 대신 새롭게 이 o가 답이 될 가능성이 생김

#### 응용1 +
- 문자열 이 xxxxxxxoooooooo!!!!!!!!!!####### 일때 !의 가장 오른쪽 인덱스 구하기
- 'x'일 때, 'o'일 때, '!'일 때, '#'일 때에 따라 답이 아닌 후보들은 배제해 나가기


### 숫자 카드

- 3가지 풀이

#### 1. 이진탐색


#### 2. 방문처리(카운팅 배열)

- cnt = `[0] * 2000000000000`
- 이후 값이 들어오면 그 인덱스를 증가시킨다
- 추후에 인덱싱으로 값이 존재하는지 확인
- int 100만개면 4Mb


#### 3. 투포인터 (오프라인 쿼리)
- 둘다 정렬하고 앞에서부터 확인하면서 넘어가기
- 출력 순서를 원래대로 맞추는 것을 고민할 것


### 숫자카드 2
- 카운팅 배열은 그대로 풀어도 되지만, 이진탐색은 조금 복잡해진다

#### 풀이 1
- 3 중에서 가장 왼쪽, 오른쪽걸 찾은 뒤에 그 차이를 구하면 개수를 구할 수 있다.

#### 풀이 2 (lower_bound, upper_bound)
- lower_bound(x) : x보다 크거나 같은 것들 중 제일 왼쪽 인덱스
- upper_bound(x) : x보다 큰 것들 중 제일 왼쪽 인덱스
- 정답은 upper_bound - lower_bound
- bound를 구하는 방법
	- xxxxxxxooooooo 처럼 3보다 크다, 작다를 기준으로 판단
	- 풀이1은 3가지 경우를 보지만, 얘는 2가지 경우만 보니까 아주 조금 더 편한 느낌
	- 다른 문제에서 더 잘 활용도 가능함



## 3. 매개변수 탐색

### 나무 자르기
- 먼저 완탐
	- 0~20까지 모든 높이에서 다 잘라본다
	- 즉, 이 높이가 가능하냐? 의 문제로 바꿀 수 있다
- 최대 / 최소를 찾는 최적화 문제를, 어떤 값을 가져와서 이 값이 되냐 안되냐의 결정문제로 바꾸는 것이 매개변수 탐색
	- sleepin in class 역시 최적화 문제이지만 약수를 기준으로 만들 수 있는지 체크했었다 -> 이진탐색이 안들어간 parametric search
- 완탐의 경우
	- 모든 높이에서 잘라보기 (10억)
	- 이 높이가 답이 되는 지 체크 (N)
- 즉 10억을 이진탐색으로 최적화 가능

>[!Important] 완탐 -> 매개변수 탐색
>- 매개변수 탐색은 최소, 최대를 찾는 문제를 결정 문제로 바꾸는 것이 핵심
>- 완탐으로 시작하면 모든 값에 대한 결정문제로 변경됨
>- 어떻게 최적화 할 수 있을 것인지에 대한 고민에 이진탐색을 활용
>- 이진탐색이 쓰일 수도 있지만, 안쓰일수도 있다.
