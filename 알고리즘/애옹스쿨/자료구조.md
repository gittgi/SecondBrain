# 자료구조

```table-of-contents
```

## 1. 메모리 구조
- 프로그램을 실행하면, 메모리(RAM)에 해당 프로세스를 위한 공간이 잡힙
	- 해당 공간은 다섯 구간으로 나뉨
		- 크기가 변하는 공간 (지역변수 등 가변적인)
			- 위에서부터 내려오는 스택
				- Array를 할당할 때 크기를 고정시켜놓고 스택에 저장
			- 밑에서부터 올라가는 힙 
		- 크기가 정해진 세 공간
			- 전역변수를 위한 공간
			- 상수를 위한 공간
			- 코드를 위한 공간

## 2. 배열
- 고정적인 크기의 배열 (C등의 로우레벨 언어)
	- 스택에 저장됨
	- 메모리 상에 위치가 **연속으로 저장**되어 있기 때문에, 인덱스 주소를 가지고 O(1)에 바로 구할 수 있다. -> 랜덤 액세스가 가능
	- 배열의 크기를 키우고 싶어져도, 이미 배열 밑의 스택 공간에 또 저장되어 있는 것이 있을 수 있기 때문에, 연속적으로 저장할 수 없어서 배열의 크기를 늘릴 수 없다.
 - 고정적인 크기의 배열이 아니라 동적으로 크기가 변할 수 있는, 동적할당을 사용하고 싶다면?
	- 스택에는 Array가 저장되어 있는 위치만 저장해두고
	- 힙에 실제 Array를 저장
	- 추후에 Array크기를 늘리고 싶은 경우, 밑에 저장한 Array를 지워 버리고 힙 위에 다시 만들어서 저장
	- 이때 기존 Array에 있던 내용을 1대1로 복사시켜야 함 -> O(n)이 걸리므로 너무 오래걸림

## 3. 크기 가변 배열 (amortized)
- C++의 vector, Java의 ArrayList등 (python은 그냥 기본)의 경우, 랜덤액스도 되면서, 동적할당도 되면서, 복사에 필요한 O(n)이 필요하지 않는 방법을 구현했다
- 기본적으로 ArrayList를 만들면, 넉넉한 사이즈로 생성해줌
	- add를 통해서 요소를 추가하면, 넉넉한 사이즈를 다 채울 때까지는 O(1)의 속도로 추가 가능
	- 만약 넉넉한 사이즈를 다 채우게 되면, 이전에 할당한 사이즈의 두배로 공간을 잡고 O(n)의 속도로 복사한 후에, 다시 O(1)로 요소 추가
	- 즉, 여유공간이 꽉 찰때 까지는 O(1), 꽉차는 시점에만 한번의 복사 과정을 거치게끔 함
		- 매 복사시마다 2배씩 공간을 늘려주기 때문에, 생각보다 많은 연산이 요구 되지 않는다.
			- 초기 배열 사이즈를 5, append를 100번한다고 하면
			- 100 + 5 + 10 + 20 + 40 + 80 의 연산이 필요하고
			- 이는 `100 + 5 * (1 + 2 + 4 + 8 + 16)`이게 되고, 이는 `100 + 5 * 32` 보다 작을 것이다.
			- 결론적으로 보수적으로 잡아도, append N번의 연산 수는 N + 2N 을 넘지 않을 것이고,
			- 이는 마치 append N번을 통으로 보았을 때 O(n)으로 작동하는 것이기 때문에, 
			- 사실상 append 1번의 시간 복잡도는 *마치* O(1)처럼 작동 -> **amortized O(1)**[^1]

## 4. 연결 리스트
- 연속된 배열 사이에 다른 연속적인 배열을 집어 넣는 것은 매우 어려움 (배열의 뒷 값을 모두 밀어내야 하기 때문)
- 이를 쉽게하기 위해 연결리스트 고안
- 각 요소가 자신 뒤에 오는 요소의 위치를 같이 저장해두는 것이 핵심
	- 다른 배열을 배열 사이에 끼워넣고 싶다면, 해당 위치의 요소의 다음 위치를 끼워 넣으려는 배열의 시작으로 지정해주고, 마찬가지로 요소 마지막도 연결관계만 재조정 하면 됨
	- 그러나 이 방식의 경우에는 **랜덤 액세스를 포기**한 방식

## 5. 스택
- 크기가 가변인 배열에서, 똑같이 append가 가능하되 꺼낼 때는 가장 마지막 것부터 꺼낼 수 있는 자료구조
- 브라우저 및 프로그램의 뒤로가기와 앞으로가기 기능 역시 스택으로 구현 가능
- java
```java
import java.util.Stack;

Stack<Integer> st = new Stack<>();
st.push(3);
System.out.print(st.peek());
System.out.print(st.size());
if(!st.isEmpty()) {
	st.pop()
}
```

- python은 리스트 사용

## 6. 큐
- 큐는 들어갔던 순서대로 꺼내지는 자료구조
- java
```java
import java.util.Queue;
import java.util.LinkedList;

Queue<Integer> que = new LinkedList<>();
que.add(3);
System.out.print(que.peek());
System.out.print(que.size());
if(!que.isEmpty()) {
	int x = que.poll()
}

```

- python
```python
from collections import deque

que = deque()
que.append(3)
# appendleft는 왼쪽에서 넣는것
print(que[0])
print(len(que))
que.popleft()

```

## 7. 덱
- **D**ouble **E**nded **Que**ue : 양쪽에서 다 뺄 수 있는 큐

## 8. 그래프
- 비선형 자료구조 중 하나
	- 선형 자료구조의 경우 데이터의 순서가 중요
	- 비선형 자료구조는 데이터간의 관계를 표현하기 위한 자료구조
- 그래프는 방향 그래프와 무향 그래프
	- 방향 그래프의 경우 a -> b 방향이 있음
	- 무향 그래프의 경우 방향 그래프로 치면 쌍방으로 간선이 존재하는 경우
- 각 데이터(객체)를 노드(정점)이라고 표현
- 각 관계는 엣지(간선)이라고 표현
- 그래프를 사용하는 목적
	- 그래프에서의 정점은, 각 객체의 정보를 담고 있다
	- 각 간선은 객체간의 관계에 대한 정보 (어디에서 어디로? 얼마나?)
		- 이때 `어디에서 어디로?`는 간선의 **방향**
		- `얼마나?` 는 **가중치**로 표현

## 9. 트리 (기초)
- 맨 위의 노드를 루트 노드로 표현
- 트리의 조건
	- 루트 노드에서 아래로만 뻗어나가는 간선들
	- 위로 가는 간선은 반드시 **하나만** 있을 것 (아래로는 몇개씩 있어도 괜찮)
- 특정 노드 기준으로, 위에 있는 건 부모노드, 아래 있는 건 자식 노드
- 위로 쭉 있는 노드들은 조상이라고 표현
- 자식 노드가 없는 노드는 리프 노드라고 표현


## 10. 이진 탐색 트리 (기초)
- 루트부터 시작해서, 자기보다 크면 오른쪽, 작으면 왼쪽으로 내려서 확인
- 만약 비었으면 해당 자리에 추가
- 만약 해당 이진 탐색 트리에서 특정 값을 찾기 위해서는
	- 루트 노드 부터 값을 비교해서, 찾는 값이 더 크면 오른쪽, 작으면 왼쪽으로 가서 탐색 지속
	- 탐색 과정은 트리의 높이만큼만 탐색하면 된다.
		- 이상적인 경우에는 O(logN) 정도
		- 최악의 경우에는 O(N) 정도 -> 트리가 선형이 되어버린 경우
		- 트리가 잘 만들어질까는 결국 입력되는 값의 순서에 따라..
		- 따라서 트리를 만들면서 밸런스를 맞춰주는 방식이 여러개 있음 (AVL, Red Black 트리 등)
			- 구현량이 많기 때문에, 라이브러리를 사용할 것
			- 이런 예쁜 이진 탐색 트리를 BBST(Balanced Binary Search Tree)라고 부르고
			- O(logN)의 탐색속도를 보장
			- 보통 계속해서 값이 추가되면서 검색하는 경우에 사용 (한번에 정렬 해도 된다면 그냥 정렬할 것)
- BBST 사용 예시
	- Set과 Map
- Set
	- 랜덤 액세스는 안됨, 다만 값을 넣거나 찾는 것이 O(logN)에 가능
	- Java
	```java
	import java.util.TreeSet
	
	TreeSet<Integer> s = new TreeSet<>();
	s.add(5);
	s.add(10);
	s.add(8);
	s.add(9);
	
	if(s.contains(9)) // 이러면 있는 것
	for (int x : s)
	
	```

	- python의 경우에는 TreeSet이 없음... HashSet으로 값이 있는지 없는지 체크 정도 가능 (순서대로 정렬은 x)
	```python
	s = set() # HashSet...
	s.add(5)
	s.add(10)
	s.add(8);
	s.add(9);
	
	if 9 in s: # 이건 가능 (대부분의 상황에서 O(1)로 작동하지만, 경우에 따라 O(n)으로 작동하기도..)
	
	```


- Map
	- 문자열 키를 만들고 싶거나 할 때
	- 키를 사전순으로 비교해서 크면 오른쪽, 작으면 왼쪽에 저장 (키 : 밸류를 묶어서 노드로 저장)
	- 나중에 문자열 키를 이용해서 찾아 올 수 있음
	- Java
	```java
	import java.util.TreeMap
	TreeMap<String, Integer> m = new TreeMap<>();
	m.put("ab", 3);
	m.put("bc", 5);
	m.get("ab");
	m.getOrDefault("ab", -1);
	if (m.contains("ab")) {}
	```

	- python
	```python
	m = dict()
	m["ab"] = 3
	m["bc"] = 5
	m.get("ab")
	m.get("ab", -1)
	
	# 카운팅 배열 만들때
	m[word] = m.get(word, 0) + 1
	```

## 11. 힙 (우선순위 큐)
- 다익스트라에서 계속


## 12. 해시
- 해싱을 통해 문자열을 해시값으로 변환 -> 해당 해시값으로 빠르게 인덱싱할 수 있도록 저장해두는 것이 해시
- 다만 그렇게 되면 문자열이 너무 커지는 경우에는 해시를 저장할 배열이 너무 커지기 때문에, 적당히 큰 소수 (1000007)등으로 모듈러 연산해서 저장하는 것이 일반적
- 그런데 서로 다른 문자열끼리 우연히 같은 해시값이 나오면 해싱충돌의 가능성...
	- 충돌되는 값에 연결리스트로 값을 적어주는 방법
	- 충돌되는 값에 트리를 넣어주는 방법 등으로 할 수 있다
- 어떤 방법을 쓰든, 악의적으로 해싱 충돌이 계속 일어나는 테스트케이스를 제시하면, 일반 배열을 쓰는 것과 다름 없는 속도가 나온다..
- 평균적으로 HashMap이나 HashSet이 더 빠르지만, 해싱 충돌이 과하게 걸리는 경우 TreeMap, TreeSet이 더 빠를 수 있다.
- 다만 TreeMap과 TreeSet의 경우에는 정렬된 상태가 기본적으로 유지되고 있고, Hash 쪽은 그냥 존재 여부만 확인할 수 있음



[^1]: amortized : 분할 상환, O(N)인 경계값을 O(1)인 애들이 분할해서 상환한다 치면, 전체적으로 봤을 때는 마치 O(1)처럼 작동되는 것을 보이기 때문에 amortized(분할 상환)이라는 개념을 적용 

