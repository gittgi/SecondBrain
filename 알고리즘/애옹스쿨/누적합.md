# 누적합

```table-of-contents
```



## 0.  쿼리 문제란?
- 뭐 하나(수열, 트리, 그래프) 주고 , 이러이러한 것들을 q번 반복해라
- 쿼리 4종류
	- 점 update : 세번째 값을 5로 바꿔라, 세번째 값에 3을 더하라
	- 구간 update : 2~5 구간에 3씩 더해라, 1~2 구간을 모두 2로 바꿔라
	- 점 get : 세번째 값이 뭐냐, 다섯번째 값이 홀수냐
	- 구간 get : 1~3 구간의 합을 구해라, 2~5 구간의 짝수의 갯수를 구하라
- 쿼리 문제의 경우에는 자료구조, 알고리즘을 활용해서 최적화가 진행됨
	- 각 알고리즘 마다 트레이드 오프가 있다
	- 코딩 테스트 범위에서는 누적합, 세그트리, 펜윅트리, sqrt decomposiotion 등이 있다
	- 그 중에서는 누적합이 가장 쉽고 많다 (세그트리가 쏘카에 최근 나옴)

##  1.  기본 누적합
- 맨 앞에서부터 그 위치까지의 합이 누적합
```python
0 5 3 3 2 1
0 5 9 12 14 15
prefix[i] => [1, i] 구간의 합
```
### 1. 어떻게 구하는지
- `prefix[i] = prefix[i-1] + arr[i]`
- 한칸 구하는데 O(1)에 구하기 때문에 전체는 O(n)
### 2. 어떻게 쓰는지
- `[s, e]` 구간의 합 => `prefix[e] - prefix[s-1]` => O(1)
- 원본 배열에서의 **구간 get 쿼리 (O(n))을 구간합 배열의 점 get 쿼리 (O(1)) 두번**으로 최적화함

연속 부분 수열을 자꾸 읽어야 하는 경우 -> 누적합 전처리 후에 몇개의 점만 보면서 처리하는 것으로 최적화

- Dict를 쓰는 경우
	- 배열의 인덱스가 너무 커지는 경우 (10억, 20억)
	- 문자열을 인덱스로 사용하고 싶다

## 2. 응용
- 수열 합 구하기 -> 구간 get 쿼리 여러번
	- 얘는 슬라이딩 윈도우로도 풀 수 있음
	- 투포인터 중에 s 랑 e가 똑같이 움직여서 구간의 크기를 유지하는 것을 슬라이딩 윈도우 알고리즘
	- e 증가시키다가 s가 따라오는 방식이 inch worm (자벌레) 알고리즘
- a, b, c, d, a, s, b, s, s,a ...
	- 여기서 구간에서 b 의 갯수 구하기
	- b만 1로, 나머지는 0으로 해서 구간합으로 알아낼 수 있음
- 내 앞의 최대값을 구하는 방법
	- 0 1 3 5 2 6 2 3 8 3
	- 0 1 3 5 5 6 6 6 8 8
	- 뒤는 역으로 계산하면 됨




## 3. 2차원 누적합
- 누적합 만들 때는, 윗줄과 왼쪽 세로줄 다 채우고
	- 왼쪽 상자 + 위쪽 상자 - 중복되는 작은 상자 + 자기 값으로 구하기
- 큰 사각형 - (직사각형 + 직사각형) + 중복된 작은 사각형

## 4. imos
- 점 업데이트가 일어나면, 누적합 배열에서는 구간 업데이트가 되어버림...
	- get은 O(1)이 되지만, update는 O(n)이 되어버림
- 하지만 **구간 업데이트가 모두 끝난 뒤에 get을 하는 경우**에는 imos를 써볼 수 있다
	- update 과정중에는 누적합을 구하지 않다가
	- update가 다 끝나면 그때 누적합을 구하는 방식

- 0 0 0 5 0 0 0 0 
- 0 0 0 5 5 5 5 5 -> 하나가 바뀌면 누적합 뒤에가 다 변한다
- 0 0 0 5 0 0 -5 0 
- 0 0 0 5 5 5 0 0 -> -5로 구간의 끝을 표시해두면, 뒤에는 처리 안된셈이 된다.
- 이처럼 시작과 끝만 표시해두고 누적합을 구하면, 최종 업데이트 해줄 배열이 생김
- 원본 배열에 더해주면 업데이트 끝



## 5. 기타
- **연속 부분 수열과 관련된 문제**의 경우에는 구간합으로 접근해보는 건 어떨지 한번쯤 생각해보는 것도 좋다. 문제가 완전히 달라질 수 있기 때문이다.



## 6. 문제풀이

### 정렬
- 완탐부터 생각
	- 하나씩 빼보고 정렬 상태인지 확인 (n * n)
- 둘중 하나를 최적화해야 한다.
	- 뺀 뒤의 상태가 정렬 상태인지 확인하는 걸 최적화하는 걸로
- `prefix[i]` 까지의 수열이 정렬되어 있는지 T, F를 저장
- `suffix[i]` 부터의 수열이 정렬되어 있는지 T, F를 저장
- 이후에 i를 뻈을때 `prefix[i-1] and suffix[i+1] and arr[i-1] <= arr[i+1]`인 애를 찾으면 끝
- 같은 방식으로 최대공약수하나빼기도 가능

### 최대공약수 하나 빼기
- `prefix[i]` 까지의 최대공약수
- `suffix[i]` 부터의 최대공약수
- gcd(`prefix[i-1]`, `suffix[i+1]`)

### SKK 문자열
- S와 K말고는 쓸모 없음 -> 의미없는 문자로 변경
- 1 : 2 로 매칭되는 구간을 찾고 싶은것
- S = 2, K = -1로 대입 (나머지는 다 0)
- 합이 0인 구간 중 가장 긴 부분 수열 찾는 문제
	- 단 s와 k 가 하나도 없는 구간은 보면 안되기 때문에, 이거 처리가 어려움
	- 누적합 배열 하나 더 만드는 것으로 해결 (S만 세는 누적합 배열 - > S가 있는지 확인 가능)

### 나는 휘파람을 정말 못불어
- h를 찾고 해당 h까지의 w갯수, h 부터의 e갯수를 prefix, suffix로 해결
- e 조합 수는 2^n - n(하나씩 뽑는 경우) - 1(아무것도 선택 안한 경우)
- 즉 하나의 h는 W 가짓수 * e의 조합수

### 오타
- 올바른 괄호 문자열 (VPS)
- 하나씩 바꿔본다
- 지운 후의 문자열이 VPS인지 확인해보자
	- 확인 방법1 : 스택 (여는 괄호가 나오면 넣고, 닫는 괄호가 나오면 스택에서 뺀다 -> 마지막에 스택에 남아 있는 걸로 판단, 중간에 언더플로가 없어야 함)
	- 확인 방법2 : 누적합으로 1, -1을 이용해서 음수가 없으면서 마지막 값이 0이면 vps
- 만약 괄호를 바꾸면 2씩 증가 혹은 감소
- `prefix[i]` : i번째까지 vps가 맞는지(여기까지 음수가 없는지)
- `suffix[i]` :  i번 부터 모두 2 이상인지 확인 (+2 해주는 경우에는 suffix는 안봐도 됨)
- + 맨 끝이 0이 되는지까지 확인이 되면 cnt += 1