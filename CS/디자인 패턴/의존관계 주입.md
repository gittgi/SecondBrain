# 의존관계 주입

- 외부에서 두 객체 간의 관계를 맺어주는 디자인 패턴
- 두 객체 사이에 인터페이스를 두는 것으로, 클래스 레벨에서는 의존관계가 고정되지 않도록 하고, 대신 런타임 시에 관계를 동적으로 주입
	- 정적인 클래스 의존관계는 해당 객체가 인터페이스에 의존하고 있음
	- 어플리케이션이 실행되고, 의존성 주입이 완료된 시점의 **동적인 객체 인스턴스 의존관계**에서는 인터페이스 자리에 해당 인터페이스를 구현한 구체 인스턴스가 자리하고 있음
- DI를 통해 클래스 간의 강한 결합을 낮출 수 있고, 이는 코드의 유연성과 확장성을 높일 수 있다.
- 별도의 Configuration 클래스를 통해 구현체를 생성하고, 각 구현체를 생성하는데에 있어 필요한 객체들 역시 해당 Config에서 생성하여 주입 해주는 것으로 의존관계를 동적으로 맺어준다.
	- 이때 주입해주는 방식으로는 생성자 주입, setter 주입, interface 주입 등이 있다.
	- 결국 config 파일에서는 각 클래스에 의존하는 모습이지만, 의존관계에 변경 소요가 생겼을 때 찾아보고 변경해야 하는 포인트, 책임을 config파일 하나로 좁힌 것으로 보는 것이 타당하다.
	- Config처럼 객체를 생성하고 관리하면서 의존관계를 설정해 주는 것을 [IoC](제어의%20역전.md)컨테이너, DI컨테이너라고 부른다. (혹은 어셈블러, 오브젝트 팩토리 등의 명칭도 있음)

- 결과적으로 [SOLID](SOLID.md)의 사항들을 지킬 수 있게 됨
	- 결과적으로 구체 클래스 대신 인터페이스에 의존하게 됨 (의존관계 역전 원칙) 
	- 같은 인터페이스를 구현한 구현체로 자유롭게 기능 확장 가능 (개방 폐쇄 원칙)
	- 객체를 생성하고 연결하는 역할을 컨테이너가 전담하기 때문에 각 객체는 다른 객체의 생성은 신경 쓸 필요 없이 해당 객체를 사용만 하면 됨 (단일 책임 원칙)

- 스프링에서는 [스프링 컨테이너](스프링%20컨테이너.md)가 DI 컨테이너의 역할을 수행한다.






---
