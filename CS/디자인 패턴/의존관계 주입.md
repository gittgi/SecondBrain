---
aliases:
  - DI
tags:
  - 디자인패턴
  - CS_지식의_정석
---
# 의존관계 주입

```table-of-contents
```


## 의존관계 주입 요약

### 의존성 주입
- 메인 모듈이 다른 하위 모듈에 대한 의존성을 직접 주기보다는, 중간에 의존성 주입자가 간접적으로 의존성을 주입하도록 하는 방식

### "의존한다"의 의미
- "A가 B에 의존한다"는 뜻은, B가 변하면 A에도 영향을 미칠 수 있다는 뜻
	- B의 메소드 명이나 메소드 리턴 타입 등이 변경되면, 이에 의존하고 있는 A 역시 변경이 필요해진다.
- 쉽게는 A 코드에 B가 쓰여 있으면 A가 B에 의존한다고 볼 수 있다.

### 의존관계 역전 원칙 (DIP)
- 의존성 주입을 할 때는 의존관계 역전 원칙([DIP](../../JAVA/SOLID.md))이 적용됨
	- 상위 모듈은 하위 모듈에 의존해서는 안됨 -> 둘 다 추상화(인터페이스)에 의존할 것
	- 추상화는 세부사항에 의존해서는 안됨 -> 세부 사항은 추상화에 따라 달라져야 함

### 의존성 주입의 장점
- 외부에서 모듈을 생성하여 집어 넣는 구조가 되기 때문에, 쉽게 교체할 수 있는 구조가 가능 (스프링에서 DB 변경에 따라 필요한 [Repository](../../미완성%20문서/@Repository.md) 등을 쉽게 교체하는 등)
- 단위 테스팅 및 마이그레이션[^1]이 쉬워짐
- 어플리케이션 의존성 방향이 좀 더 일관되기 때문에, 코드를 추론하기가 쉬워짐

### 의존성 주입의 단점
-  모듈을 더 생성 하는 셈이기 때문에 복잡도가 증가
- 종속성 주입은 컴파일 시점이 아니라 런타임 시점에 일어나기 때문에, 컴파일을 할 때에는 종속성 주입에 관한 에러를 잡기가 어려울 수 있음


##  의존관계 주입 상세

- 외부에서 두 객체 간의 관계를 맺어주는 디자인 패턴
- 두 객체 사이에 인터페이스를 두는 것으로, 클래스 레벨에서는 의존관계가 고정되지 않도록 하고, 대신 런타임 시에 관계를 동적으로 주입
	- 정적인 클래스 의존관계는 해당 객체가 인터페이스에 의존하고 있음
	- 어플리케이션이 실행되고, 의존성 주입이 완료된 시점의 **동적인 객체 인스턴스 의존관계**에서는 인터페이스 자리에 해당 인터페이스를 구현한 구체 인스턴스가 자리하고 있음
- DI를 통해 클래스 간의 강한 결합을 낮출 수 있고, 이는 코드의 유연성과 확장성을 높일 수 있다.
- 별도의 Configuration 클래스를 통해 구현체를 생성하고, 각 구현체를 생성하는데에 있어 필요한 객체들 역시 해당 Config에서 생성하여 주입 해주는 것으로 의존관계를 동적으로 맺어준다.
	- 이때 주입해주는 방식으로는 생성자 주입, setter 주입, interface 주입 등이 있다.
	- 결국 config 파일에서는 각 클래스에 의존하는 모습이지만, 의존관계에 변경 소요가 생겼을 때 찾아보고 변경해야 하는 포인트, 책임을 config파일 하나로 좁힌 것으로 보는 것이 타당하다.
	- Config처럼 객체를 생성하고 관리하면서 의존관계를 설정해 주는 것을 [IoC](../제어의%20역전.md)컨테이너, DI컨테이너라고 부른다. (혹은 어셈블러, 오브젝트 팩토리 등의 명칭도 있음)
		-  스프링에서는 [스프링 컨테이너](../../Spring/스프링%20컨테이너.md)가 DI 컨테이너의 역할을 수행한다.

- 결과적으로 [SOLID](../../JAVA/SOLID.md)의 사항들을 지킬 수 있게 됨
	- 결과적으로 구체 클래스 대신 인터페이스에 의존하게 됨 (의존관계 역전 원칙) 
	- 같은 인터페이스를 구현한 구현체로 자유롭게 기능 확장 가능 (개방 폐쇄 원칙)
	- 객체를 생성하고 연결하는 역할을 컨테이너가 전담하기 때문에 각 객체는 다른 객체의 생성은 신경 쓸 필요 없이 해당 객체를 사용만 하면 됨 (단일 책임 원칙)










[^1]: 다른 운영환경으로 이동하는 것 (ex. DB 이동, 데이터 이동 등)
