# 싱글톤 패턴


```table-of-contents
```


## 싱글톤 패턴이란?

- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 따라서 객체 인스턴스가 2개 이상이 되는 것을 막아야 한다.
- 싱글톤 패턴이든 스프링과 같은 싱글톤 컨테이너든, 여러 클라이언트가 동시에 하나의 인스턴스를 사용할 수 있기 때문에, 해당 인스턴스의 상태가 유지되어서는 안된다 -> stateless한 설계가 필요

### 장점
- 인스턴스 생성 비용 감소
	- 따라서 인스턴스 생성에 많은 비용이 드는 I/O 작업에 주로 사용
	- I/O 바운드 작업의 예시 : 네트워크 통신, DB 연결, 파일 시스템(디스크) 연결

### 단점
- 의존성이 높아짐
	- 하나뿐인 인스턴스가 바뀌면, 이와 관련된 다른 모듈들도 전부 바뀌어야 하는 가능성
- TDD 할 때 걸림돌
	- 단위 테스트는 서로 독립적이어야 하며, 테스트 순서와는 무관해야 함
	- 인스턴스가 하나이기 때문에, 테스트마다 독립적인 인스턴스 구성이 어렵다
## 어플리케이션에서의 싱글톤 패턴

- 복수의 고객이 동시에 요청하는 경우, 매 요청마다 새로운 컨트롤러나 서비스등의 객체를 생성하게 된다면 메모리 낭비가 심하다.
- 따라서 하나의 객체만 생성하고, 같은 객체를 공유하게 하는 싱글톤 패턴이 필요한 것
- 다만 싱글톤 패턴에도 문제점은 있다
	- 싱글톤 패턴을 구현하는 코드 자체가 많을 수 있다.
	- 의존관계를 설정할 때, 클라이언트가 구체 클래스에 의존한다.
	- 클라이언트가 구체 클래스에 의존하기 때문에 OCP를 위반할 수 있다.
	- 독립적이고 반복적인 테스트가 어렵다
	- 내부 속성 변경이나 초기화가 어렵다
	- private 생성자로 자식 클래스를 만들기 어렵다
- 결론적으로 유연성이 떨어질 수 있다. ([안티패턴](../../미완성%20문서/안티패턴.md)으로 불리기도 한다)

- 따라서 이러한 문제점을 보완하기 위해선 [싱글톤으로 관리되는 컨테이너](../../Spring/스프링%20컨테이너.md)를 활용하는 것이 필요


## 싱글톤 패턴을 구현하는 7가지 방법

### 1. 단순 메서드 호출
- 싱글톤 패턴 생성 여부를 확인하고, 싱글톤 인스턴스가 아직 없다면 새로 만들기 / 있다면 이미 있는 인스턴스를 반환
```java
public class Singleton { 
	private static Singleton instance; 
	
	private Singleton() {
	
	} 
	public static Singleton getInstance() { 
		if (instance == null) { 
			instance = new Singleton(); 
		} 
		return instance; 
	} 
}
```
- 그러나 멀티 스레드 환경에서는 2개 이상의 인스턴스가 생겨버릴 가능성 (원자성 결여)


### 2. synchronized 키워드 사용
- synchronized : 최초로 접근한 스레드가 해당 메서드를 호출 할 때, 다른 스레드가 같은 메서드에 접근하지 못하게 잠그는 키워드
- 이를 통해 스레드 세이프하게 싱글톤 구현 가능
```java
public class Singleton {
	private static Singleton instance;

	private Singleton() {
	
	}

	public static synchronized Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}
```
- 그러나 여러 모듈이 동시에 getInstance를 호출하게 되면, 락이 걸려있기 때문에 접근하지 못하고 대기, 성능저하 발생


### 3. & 4. 정적 멤버 & 정적 블록
- 정적 멤버 / 블록은 런타임이 아니라 최초에 JVM이 클래스를 로딩할 때, 미리 인스턴스를 생성
- 클래스 로딩과 동시에 싱글톤 인스턴스를 만들고, 모듈들이 인스턴스를 요청하면 이때 만든 인스턴스를 반환하는 방식
#### 정적 멤버
```java
public class Singleton {
	private final static Singleton instance = new Singleton();

	private Singleton() {

	}

	public static Singleton getInstance() {
			return instance;
	}
}
```

#### 정적 블록
```java
public class Singleton {

	private static Singleton instance = null;

	static {
		instance = new Singleton();
	}

	private Singleton() {

	}

	public static Singleton getInstance() {
		return instance;
	}
}
```

- 그러나 불필요한 자원 낭비 가능성
    - 싱글톤 인스턴스가 필요없는 상황에서도 무조건 싱글톤 클래스 호출 및 인스턴스 생성과정을 거치게 됨


### 5. 정적 멤버 + Lazy Holder를 이용한 중첩 클래스 방식
- (3), (4) 에서 발생하는 무조건적인(불필요한) 인스턴스 생성을 방지하기 위해, 내부 클래스를 하나 더 만드는 방식
- 이 방법을 통해 getInstance() 가 호출 될 때에만, 해당 내부 클래스가 로딩 되어 인스턴스가 생성되도록
- 인스턴스가 불필요하게 생성되어 메모리를 점거하는 것을 방지
```java
class Singleton {
	private static class singleInstanceHolder {
			private static final Singleton INSTANCE = new Singleton();
	}
	public static Singleton getInstance() {
			return singleInstanceHolder.INSTANCE;
	}
}
```

### 이중 확인 잠금 (DCL, Double Checked Locking)
- 인스턴스 생성 여부를 싱글톤 패턴 잠금 전에 한번, 실제 객체 생성 전에 한번, 총 두번 체크 함
- 이 경우 인스턴스가 존재하지 않는 상황에서만 잠금을 걸기 때문에 (2)에서 발생했던 문제점 해결
- 이 때 volatile 키워드 사용
    - 자바의 경우 스레드가 2개 열리면 메인메모리가 아닌 코어에 각각 있는 캐시메모리에서 변수를 가져옴
    - 이러한 이유로 변수 값 불일치 문제가 발생할 수 있음
    - 따라서 volatile 키워드를 통해 메인 메모리 기반으로 저장하고 읽어오게 하는 것으로 문제를 해결
```java
public class Singleton {

	private volatile Singleton instance;

	private Singleton() {

	}

	public Singleton getInstance() {
		if (instance == null) {
			synchronized (Singleton.class) {
				if (instance == null) {
						instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```


### 7. Enum 키워드 활용
- enum의 인스턴스가 기본적으로 스레드 세이프하다는 점을 이용
```java
public enum SingletonEnum {
	INSTANCE;
	public void oortCloud() {

	}
}
```


> [!Important] 가장 추천하는 싱글톤 패턴 구현 방법
> - 가장 널리 이용되는 (5)
> - 이펙티브 자바의 저자 조슈아 블로크가 강추하는 (7)번
> - 이외에도 다양한 방식을 중첩 적용해서 고도화된 싱글톤을 구현하기도 함
    
    

---
